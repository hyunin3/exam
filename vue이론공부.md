######
Front-end 개발은 wep app 또는 웹사이트의 UI/UX를 제작하고 관리하는 과정
HTML. CSS, Java Script 주로 사용

웹앱은 웹 브라우저에서 실행되는 어플리케이션 소프트웨어. 웹 페이지가 그대로 보이는 것이 아니라 디바이스에 설치된 앱처럼 보임. 웹 페이지가 디바이스에 맞는 UI/UX로 표현

SPA(Single Page Application)
이전까지는 요청에 대해 페이지 별로 템플릿을 반환했다면 SPA는 최초의 1장의 HTML만 
전달받아 모든 요청에 대응함. CSR 방식으로 요청하기 때문

######
CSR(Client Side Rendering)
최초 한 장 HTML을 받아오는데 서버로부터 빈 HTML을 받음. 각 요청에 대한 대응을 js를 사용하여 필요한 부분만 다시 렌더링. 필요한 페이지를 서버에 AJAX로 요청. 
서버는 화면 그리는데 필요한 데이터를 JSON방식으로 전달하고 JSON데이터를 js로 처리해서
DOM 트리에 반영(렌더링) 

모든 HTML 페이지를 서버로부터 받아서 표시하지 않아도 되기에 트래픽이 감소하고 응답속도가 빨라짐. 매번 새로고침하는 것이 아니라 필요한 부분만 고쳐나가기에 각 요청이 끊임없이 진행. UX향상. BE와 FE의 역할이 명확하게 분리되며 협업이 용이해짐

######
다만 CSR은 첫 구동 시 필요한 데이터가 많을 수록 최초 작동까지 오랜 시간이 걸림. 또한 서버가 제공하는 것은 빈 html이기 때문에 검색 엔진 최적화가 어려움

CSR과 SSR을 필요에 따라 적합하게 활용해야함

######
Vue 상대적으로 낮은 진입장벽을 가진 fe 프레임워크

MVVM pattern 소프트웨어 아키텍처 패턴의 일종
view- 우리 눈에 보이는 부분, DOM역할
model- 실제 데이터, json역할
view model- vue, view와 연결되어 액션을 주고받음. 모델이 변경되면 뷰와 뷰 모델 모두 변경. 사용자 화면에서 이름 바꾸면 자동으로 연동되어 모두 바뀜. 메서드 정의시 화살표 함수 사용하면 안된다. MVC패턴에서 컨트롤러 대신 뷰 모델 들어간 패턴. 

######
Vue instance
vue CDN가져오고 new연산자를 사용한 생성자 함수 호출. 뷰 인스턴스 생성

el 뷰 인스턴스와 DOM을 연결하는 옵션. 뷰와 모델을 연결하는 역할. 뷰 인스턴스와 연결되지 않은 DOM외부는 vue의 영향을 받지 않음. 첫번째 인자로 object 작성하고 el옵션에 #app작성하여 DOM연결

data 뷰 인스턴스의 데이터 객체 혹은 인스턴스 속성. 추가된 객체의 각 값들은 
this.message형태로 접근 가능

methods 뷰 인스턴스의 메서드들을 정의하는 곳. 화살표 함수 사용불가

######
html의 기본 속성이 아니라 Vue가 제공하는 특수 속성의 값으로 data작성
:을 통해 전달인자를 받을 수 있고 .으로 바인딩

v-text는 {{}}과 비슷한 역할

v-show 표현식에 작성된 값에 따라 el을 보여줄 것인지 결정. boolean값이 변경될 때 
마다 반응. 화면에서만 사라졌을 뿐 DOM에는 존재. 디스플레이 속성만 변경되는 것
isActive 변경으로 t/f 조절

v-if  v-show 와 같은 사용방법. 하지만 값이 false인 경우엔 DOM에서 사라짐
v-if v-else-if v-else 형태로 사용

v-show는 표현식 결과와 관계 없이 렌더링되므로 초기 렌더링에 필요한 비용은 더 높을 수 있으나 렌더링 후 toggle 비용은 적음

v-if는 표현식 결과가 false 일땐 렌더링되지 않으므로 초기 렌더링 비용이 더 낮을 수 
있으나 표현식 값이 자주 변경되는 경우엔 잦은 재 렌더링으로 비용이 증가할 수 있음

######
v-for
for in 형식으로 작성. 반복한 데이터 타입에 모두 사용 가능하고 (char, index)형태로 사용가능. ... 사용가능. v-for 사용시 반드시 key속성을 각 요소에 작성해야함

v-on :을 통해 전달받은 인자를 확인. addEventListener와 비슷
메서드를 통한 data조작 가능하고 @ 숏컷 제공

v-bind html 기본 속성에 vue data를 연결. : 숏컷 제공

v-model vue instance와 DOM의 양방향 바인딩. vue data 변경시 v-model로 연결된
사용자 입력 element에도 적용

######
methods- 호출될 때 마다 함수를 실행. 같은 결과에도 매번 새롭게 계산

computed- 함수의 종속 대상의 변화에 따라 계산 여부 결정. 종속 대상이 변하지 않으면
항상 저장(캐싱)된 값을 반환

watch- 특정 데이터의 변화를 감지하는 기능. watch 객체를 정의하고 감시할 대상 data를 지정하고 data가 변할 시 실행할 함수를 정의

filters- 텍스트 형식화를 적용할 수 있는 필터. 표현식 마지막에 |와 함께 추가되어야함

######
스타일 가이드 
v-for는 항상 key와 함께 사용하기
v-for를 쓴 엘리먼트에 절대 v-if 사용하지 말기

######
Node.js
자바스크립트는 브라우저를 조작하는 유일한 언어이지만 브라우저 밖에 구동할 수 없음. 런타임 환경인 Node.js로 인해 브라우저가 아닌 환경에서도 JS구동 가능해짐

npm(node package manage)
자바스크립트 패키지 관리자

구조
node_modules 파이썬의 venv와 비슷한 역할
node_modules-Babel 자바스크립트의 ES6+코드를 구버전으로 변환해주는 도구
node_modules-Webpack 모듈간 의존성 문제 해결

Module 개발하는 어플이 커지고 복잡해져서 여러개로 분리하여 관리하게 되었고 분리된 각각이 모듈. 모듈 의존성 문제를 해결해주는 작업을 Bundling이라고 하고 웹팩은 번들러 중 하나. 의존성을 웹팩이 알아서 담당해줘서 npm install을 사용해 한번에 설치하고 각각 활용 가능

package-lock.json 파이썬의 requirements.txt 역할

public/index.html Vue앱의 뼈대가 되는 html파일. base.html같은거

######
src/

1. src/assets 정적 파일을 저장하는 디렉토리
2. src/components 하위 컴포넌트들이 위치
3. src/App.vue 최상위 컴포넌트, public/index.html과 연결됨
4. src/main.js 웹팩이 빌드를 시작할 때 가장 먼저 불러오는 entry point, vue전역에서 
   활용할 모듈을 등록할 수 있는 파일

######
Component

UI를 독립적이고 재사용 가능한 조각들로 나눈 것. 기능별로 분화한 코드 조각.
src/App.vue를 루트로 하는 트리의 구조를 가짐. 유지보수와 재사용에 유리

우리가 사용하는 웹 서비스는 여러개의 컴포넌트로 이루어져 있음. 하나의 컴포넌트 만들어두면 반복되는 UI 쉽게 처리 가능. 한 화면은 여러개의 컴포넌트로 이루어질 수 있음
하나의 .vue 파일이 하나의 컴포넌트
Vue instance에서는 HTML, CSS, JavaScript 코드를 한번에 관리. 뷰 인스턴스를 기능단위로 작성

유지보수 용이, 재사용성, 확장 가능, 캡슐화, 독립적

######
Vue componene 구조
1. 템플릿(HTML): html의 보디부분, 눈으로 보여지는 요소 작성. 다른 컴포넌트를 html요소처럼 추가 가능

2. 스크립트(JS): JS코드가 작성되는 곳. 컴포넌트 정보, 데이터, 메서드 등 vue 인스턴스를 구성하는 대부분이 작성됨

3. 스타일(CSS): CSS가 작성되며 컴포넌트의 스타일을 담당

컴포넌트들이 tree구조를 이루어 하나의 페이지를 만든다. root에 해당하는 최상단
component가 App.vue 

######
Vue CLI

$vue create vue-cli    프로젝트 생성

$cd vue-cli    프로젝트 디렉토리로 이동

$npm run serve    프로젝트 실행

######
동적 웹페이지를 만들기 위해서는 한 페이지 내에서 같은 데이터를 공유해야함
component로 구분된 페이지들이 데이터를 공유하게 해야함
부모-자식 관계인 컴포넌트끼리 데이터를 주고 받게 해서 유지 보수가 용이하게 함

부모->자식 데이터 흐름은 pass pros방식
자식->부모 데이터 흐름은 emit event방식

######
pass props
요소의 속성을 사용하여 데이터 전달. 부모 컴퍼넌트의 정보를 전달하기 위한 특성
자식 컴포넌트는 pros옵션을 사용하여 수신하는 props를 명시적으로 선언해야함

정적인 데이터 static props라고 명시, prop-data-name="value"형태로 데이터 전달
속성의 키값은 kebab-case사용
데이터를 받는 하위 컴포넌트에도 props에 대해 명시적으로 작성해주어야함. 전달받은 props를 타입과 함께 명시
부모에서 넘겨주는 props는 kebab-case이고 자식에서 받는 props는 camelCase

dynamic props 변수를 props로 전달할 수 있음. v-bind 사용해서 데이터를 동적으로 바인딩. 부모 컴퍼넌트 데이터가 업데이트되면 자식 컴포넌트로 전달되는 데이터도 업데이트됨

컴포넌트의 data함수는 새로운 data객체를 반환하여 사용해야함

:dynamic-props="dynamicPros"는 앞의 키값인 dynamic-props란 이름으로 데이터 dynamicPros를 전달하겠다는 뜻. 자식 컴포넌트에선 myProps로 데이터를 받아야함

v-bind로 묶여있는 ""안의 구문은 js구문이고 숫자를 props로 전달할 때 "'1'"로 해줘야함

모든 props는 부모에서 자식으로 단방향 바인딩 형성. 부모 컴포넌트가 업데이트되면 자식 컴포넌트의 prop들이 갱신. 하위에서 prop변경은 하면 안됨

#####
emit event
상위 컴포넌트는 이벤트를 통해 데이터를 전달받음. $emit 메서드를 통해 부모 컴퍼넌트에 이벤트를 발생. $emit('event-name')가 실행되면 event-name 이벤트가 발생함

이벤트를 발생(emit)시킬 때 인자로 데이터 전달 가능. 전달한 데이터는 이벤트와 연결된 부모 컴포넌트의 핸들러 함수의 인자로 사용가능

자식 컴포넌트에서 부모 컴포넌트로 이벤트를 발생시키고 이벤트에 데이터를 담아 전달 가능
부모 컴포넌트에서는 자식 컴포넌트의 이벤트를 청취하고 전달받은 데이터를 이벤트 핸들러 함수의 인자로 사용

######
props 상위->하위 흐름은 HTML요소로 내려주니까 kebab-case
하위에서 받을 때는 자바스크립트에서 받으니까 camelCase

emit 이벤트를 발생시키면 HTML요소가 이벤트를 청취하니까 kebab-case
메서드, 변수명 등은 자바스크립트에서 사용하니까 camelCase

######
Lifecycle Hooks
각 인스턴스는 생성과 소멸의 과정 중 단계별 초기화 과정을 거침. 각 단계가 트리거가 되어 특정 로직을 실행할 수 있음

created 인스턴스가 생성된 후 호출됨. 마운트되지 않아 요소에 접근할 수는 없고 서버에서 받은 데이터를 인스턴스의 데이터에 할당하는 로직을 구현하기 적합

mounted 인스턴스가 요소에 마운트된 후 호출됨

updated 데이터가 변경되어 돔에 변화를 줄 때 호출됨

인스턴스마다 각각의 라이프사이클을 가지고 있어서 부착여부가 부모-자식 관계에 따라 순서를 가지고 있지 않음

######
State(상태) 현재에 대한 정보(data)
각 컴포넌트들은 독립적이지만 하나의 앱을 구성하기 위해서는, 여러 개의 컴포넌트가 같은 상태를 유지할 필요가 있기에 상태관리가 필요

컴포넌트의 중첩이 깊어지면 데이터 전달이 쉽지 않게 됨. 중앙저장소(store)에 데이터를 모아서 상태관리. 각 컴포넌트는 중앙 저장소의 데이터를 사용. 컴포넌트의 계층에 상관없이 스토어에 접근 가능. 스토어 데이터가 변경되면 각각의 컴포넌트는 해당 데이터의 변화에 반응하여 갱신

Vuex 중앙 저장소를 통해 상태 관리를 할 수 있게 하는 라이브러리. 규칙을 설정하고 뷰 반응성 효율적으로 사용하는 상태관리 제공

1. state 
   vue 인스턴스의 data에 해당. 중앙에서 관리하는 모든 상태 정보. 개별 컴포넌트는 state에서 데이터를 가져와서 사용. state 데이터 변화하면 해당 데이터 공유하는 컴포넌트도 자동으로 다시 렌더링. $store.state로 접근

2. mutations
   실제로 state를 변경하는 유일한 방법. methods에 해당하지만 뮤테이션에서 호출되는 핸들러 함수는 반드시 동기적이어야 함. 비동기 로직을 사용하면 변화의 시기 특정 불가.
   첫번째 인자로 state받고 commit() 메서드로 호출됨

3. actions
   비동기 작업할 수 있음. state를 직접 변경하지 않고 commit()메서드로 뮤테이션 호출해서 state변경함. context를 인자로 받고 component에서 dispatch() 메서드로 호출함

Mutations는 state를 변경하고 Action은 그 외 나머지 모든 로직을 담당


4. getters 
   computed에 해당. 스테이트를 활용하여 계산된 값을 얻고자 할 때 사용. 원본 데이터를 건들이지 않고 계산된 값을 얻을 수 있음. 첫번째 인자로 state, 두번째 인자로 getter를 받음


######
state- 중앙에서 관리하는 모든 상태 정보
mutations- state를 변경하기 위한 methods
actions- state변경 외의 모든 로직. 비동기 작업(외부 API와의 소통 등)포함 메서드
getters- state를 활용해 계산한 새로운 변수 값   

데이터 조작: component -> (actions) -> mutations -> state
(데이터의 흐름)
데이터 사용: state -> (getters) -> component
